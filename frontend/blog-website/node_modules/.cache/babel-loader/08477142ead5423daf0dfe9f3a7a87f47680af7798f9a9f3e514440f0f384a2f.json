{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar createContext = _interopDefault(require('mini-create-react-context'));\nvar PropTypes = _interopDefault(require('prop-types'));\nvar reactRouterDom = require('react-router-dom');\n\n// 值类型判断 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nvar isUndefined = function isUndefined(val) {\n  return typeof val === 'undefined';\n};\nvar isNull = function isNull(val) {\n  return val === null;\n};\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\nvar isString = function isString(val) {\n  return typeof val === 'string';\n};\nvar isExist = function isExist(val) {\n  return !(isUndefined(val) || isNull(val));\n};\nvar isArray = function isArray(val) {\n  return val instanceof Array;\n};\nvar isNaN = function isNaN(val) {\n  return val !== val;\n};\nvar isNumber = function isNumber(val) {\n  return typeof val === 'number' && !isNaN(val);\n};\n// 值类型判断 -------------------------------------------------------------\n\nvar get = function get(obj) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var defaultValue = arguments[2];\n  try {\n    if (isNumber(keys)) {\n      keys = String(keys);\n    }\n    var result = (isString(keys) ? keys.split('.') : keys).reduce(function (res, key) {\n      return res[key];\n    }, obj);\n    return isUndefined(result) ? defaultValue : result;\n  } catch (e) {\n    return defaultValue;\n  }\n};\nvar run = function run(obj) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  keys = isString(keys) ? keys.split('.') : keys;\n  var func = get(obj, keys);\n  var context = get(obj, keys.slice(0, -1));\n  return isFunction(func) ? func.call.apply(func, [context].concat(args)) : func;\n};\nvar value = function value() {\n  for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    values[_key2] = arguments[_key2];\n  }\n  return values.reduce(function (value, nextValue) {\n    return isUndefined(value) ? run(nextValue) : run(value);\n  }, undefined);\n};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n};\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\nvar getImplementation = function getImplementation() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n};\nvar implementation = getImplementation();\nvar getGlobal = function getGlobal() {\n  if ((typeof global === 'undefined' ? 'undefined' : _typeof(global)) !== 'object' || !global || global.Math !== Math || global.Array !== Array) {\n    return implementation;\n  }\n  return global;\n};\nvar globalThis = getGlobal();\nvar flatten = function flatten(array) {\n  return array.reduce(function (res, item) {\n    return [].concat(toConsumableArray(res), toConsumableArray(isArray(item) ? flatten(item) : [item]));\n  }, []);\n};\n\n/**\n * [钳子] 用来将数字限制在给定范围内\n * @param {Number} value 被限制值\n * @param {Number} min 最小值\n * @param {Number} max 最大值\n */\nvar clamp = function clamp(value, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\nvar ObjectValues = function ObjectValues(object) {\n  var res = [];\n  for (var key in object) {\n    res.push(object[key]);\n  }\n  return res;\n};\nvar body = get(globalThis, 'document.body');\nvar screenScrollingElement = get(globalThis, 'document.scrollingElement', get(globalThis, 'document.documentElement', {}));\nfunction isScrollableNode() {\n  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!isExist(node)) {\n    return false;\n  }\n  return node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight;\n}\nfunction getScrollableNodes(from) {\n  if (!isFunction(get(globalThis, 'document.getElementById'))) {\n    return [];\n  }\n  return [].concat(toConsumableArray(value(run(from, 'querySelectorAll', '*'), [])), [from]).filter(isScrollableNode);\n}\nfunction saveScrollPosition(from) {\n  var nodes = [].concat(toConsumableArray(new Set([].concat(toConsumableArray(flatten((!isArray(from) ? [from] : from).map(getScrollableNodes))), toConsumableArray([screenScrollingElement, body].filter(isScrollableNode))))));\n  var saver = nodes.map(function (node) {\n    return [node, {\n      x: node.scrollLeft,\n      y: node.scrollTop\n    }];\n  });\n  return function revert() {\n    saver.forEach(function (_ref) {\n      var _ref2 = slicedToArray(_ref, 2),\n        node = _ref2[0],\n        _ref2$ = _ref2[1],\n        x = _ref2$.x,\n        y = _ref2$.y;\n      node.scrollLeft = x;\n      node.scrollTop = y;\n    });\n  };\n}\nvar __components = {};\nvar getCachedComponentEntries = function getCachedComponentEntries() {\n  return Object.entries(__components).filter(function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n      cache = _ref2[1];\n    return cache instanceof CacheComponent ? cache.state.cached : Object.values(cache).some(function (cache) {\n      return cache.state.cached;\n    });\n  });\n};\nvar getCache = function getCache() {\n  return _extends({}, __components);\n};\nvar register = function register(key, component) {\n  __components[key] = component;\n};\nvar remove = function remove(key) {\n  delete __components[key];\n};\nvar dropComponent = function dropComponent(component) {\n  return run(component, 'reset');\n};\nvar dropByCacheKey = function dropByCacheKey(key) {\n  var cache = get(__components, [key]);\n  if (!cache) {\n    return;\n  }\n  if (cache instanceof CacheComponent) {\n    dropComponent(cache);\n  } else {\n    Object.values(cache).forEach(dropComponent);\n  }\n};\nvar refreshComponent = function refreshComponent(component) {\n  return run(component, 'refresh');\n};\nvar refreshByCacheKey = function refreshByCacheKey(key) {\n  var cache = get(__components, [key]);\n  if (!cache) {\n    return;\n  }\n  if (cache instanceof CacheComponent) {\n    refreshComponent(cache);\n  } else {\n    Object.values(cache).forEach(refreshComponent);\n  }\n};\nvar clearCache = function clearCache() {\n  getCachedComponentEntries().forEach(function (_ref3) {\n    var _ref4 = slicedToArray(_ref3, 1),\n      key = _ref4[0];\n    return dropByCacheKey(key);\n  });\n};\nvar getCachingKeys = function getCachingKeys() {\n  return getCachedComponentEntries().map(function (_ref5) {\n    var _ref6 = slicedToArray(_ref5, 1),\n      key = _ref6[0];\n    return key;\n  });\n};\nvar getCachingComponents = function getCachingComponents() {\n  return getCachedComponentEntries().reduce(function (res, _ref7) {\n    var _ref8 = slicedToArray(_ref7, 2),\n      key = _ref8[0],\n      cache = _ref8[1];\n    return _extends({}, res, cache instanceof CacheComponent ? defineProperty({}, key, cache) : Object.entries(cache).reduce(function (res, _ref10) {\n      var _ref11 = slicedToArray(_ref10, 2),\n        pathname = _ref11[0],\n        cache = _ref11[1];\n      return _extends({}, res, defineProperty({}, key + '.' + pathname, cache));\n    }, {}));\n  }, {});\n};\nvar context = createContext();\nvar Provider = context.Provider,\n  Consumer = context.Consumer;\nfunction useCacheRoute(lifecycleName, effect) {\n  if (!isFunction(React.useContext)) {\n    return;\n  }\n  var effectRef = React.useRef(function () {\n    return null;\n  });\n  effectRef.current = effect;\n  var cacheLifecycles = React.useContext(context);\n  React.useEffect(function () {\n    var off = run(cacheLifecycles, 'on', lifecycleName, function () {\n      run(effectRef.current);\n    });\n    return function () {\n      return run(off);\n    };\n  }, []);\n}\nvar useDidCache = useCacheRoute.bind(null, 'didCache');\nvar useDidRecover = useCacheRoute.bind(null, 'didRecover');\nvar isUsingNewLifecycle = isExist(React__default.forwardRef);\nvar COMPUTED_UNMATCH_KEY = '__isComputedUnmatch';\nvar isMatch = function isMatch(match) {\n  return isExist(match) && get(match, COMPUTED_UNMATCH_KEY) !== true;\n};\nvar getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n  var nextPropsMatch = nextProps.match,\n    _nextProps$when = nextProps.when,\n    when = _nextProps$when === undefined ? 'forward' : _nextProps$when;\n\n  /**\r\n   * Note:\r\n   * Turn computedMatch from CacheSwitch to a real null value\r\n   *\r\n   * 将 CacheSwitch 计算得到的 computedMatch 值转换为真正的 null\r\n   */\n\n  if (!isMatch(nextPropsMatch)) {\n    nextPropsMatch = null;\n  }\n  if (!prevState.cached && nextPropsMatch) {\n    return {\n      cached: true,\n      matched: true\n    };\n  }\n\n  /**\r\n   * Determines whether it needs to cancel the cache based on the next unmatched props action\r\n   *\r\n   * 根据下个未匹配状态动作决定是否需要取消缓存\r\n   */\n  if (prevState.matched && !nextPropsMatch) {\n    var nextAction = get(nextProps, 'history.action');\n    var __cancel__cache = false;\n    if (isFunction(when)) {\n      __cancel__cache = !when(nextProps);\n    } else {\n      switch (when) {\n        case 'always':\n          break;\n        case 'back':\n          if (['PUSH', 'REPLACE'].includes(nextAction)) {\n            __cancel__cache = true;\n          }\n          break;\n        case 'forward':\n        default:\n          if (nextAction === 'POP') {\n            __cancel__cache = true;\n          }\n      }\n    }\n    if (__cancel__cache) {\n      return {\n        cached: false,\n        matched: false\n      };\n    }\n  }\n  return {\n    matched: !!nextPropsMatch\n  };\n};\nvar CacheComponent = function (_Component) {\n  inherits(CacheComponent, _Component);\n  function CacheComponent(props) {\n    var _ref;\n    classCallCheck(this, CacheComponent);\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var _this = possibleConstructorReturn(this, (_ref = CacheComponent.__proto__ || Object.getPrototypeOf(CacheComponent)).call.apply(_ref, [this, props].concat(args)));\n    _this.cacheLifecycles = {\n      __listener: {},\n      __didCacheListener: {},\n      __didRecoverListener: {},\n      on: function on(eventName, func) {\n        var id = Math.random();\n        var listenerKey = '__' + eventName + 'Listener';\n        _this.cacheLifecycles[listenerKey][id] = func;\n        return function () {\n          delete _this.cacheLifecycles[listenerKey][id];\n        };\n      },\n      didCache: function didCache(listener) {\n        _this.cacheLifecycles.__listener['didCache'] = listener;\n      },\n      didRecover: function didRecover(listener) {\n        _this.cacheLifecycles.__listener['didRecover'] = listener;\n      }\n\n      /**\r\n       * New lifecycle for replacing the `componentWillReceiveProps` in React 16.3 +\r\n       * React 16.3 + 版本中替代 componentWillReceiveProps 的新生命周期\r\n       */\n    };\n    _this.componentWillReceiveProps = !isUsingNewLifecycle ? function (nextProps) {\n      var nextState = getDerivedStateFromProps(nextProps, _this.state);\n      _this.setState(nextState);\n    } : undefined;\n    _this.injectDOM = function () {\n      try {\n        run(_this.__parentNode, 'insertBefore', _this.wrapper, _this.__placeholderNode);\n        run(_this.__parentNode, 'removeChild', _this.__placeholderNode);\n      } catch (err) {\n        // nothing\n      }\n    };\n    _this.ejectDOM = function () {\n      try {\n        var parentNode = get(_this.wrapper, 'parentNode');\n        _this.__parentNode = parentNode;\n        run(_this.__parentNode, 'insertBefore', _this.__placeholderNode, _this.wrapper);\n        run(_this.__parentNode, 'removeChild', _this.wrapper);\n      } catch (err) {\n        // nothing\n      }\n    };\n    _this.reset = function () {\n      delete _this.__revertScrollPos;\n      _this.setState({\n        cached: false\n      });\n    };\n    _this.refresh = function () {\n      delete _this.__revertScrollPos;\n      _this.setState({\n        key: Math.random()\n      });\n    };\n    _this.__cacheCreateTime = Date.now();\n    _this.__cacheUpdateTime = _this.__cacheCreateTime;\n    if (props.cacheKey) {\n      var cacheKey = run(props.cacheKey, undefined, props);\n      if (props.multiple) {\n        var href = props.href;\n        register(cacheKey, _extends({}, getCache()[cacheKey], defineProperty({}, href, _this)));\n      } else {\n        register(cacheKey, _this);\n      }\n    }\n    if (typeof document !== 'undefined') {\n      var _cacheKey = run(props.cacheKey, undefined, props);\n      _this.__placeholderNode = document.createComment(' Route cached ' + (_cacheKey ? 'with cacheKey: \"' + _cacheKey + '\" ' : ''));\n    }\n    _this.state = getDerivedStateFromProps(props, {\n      cached: false,\n      matched: false,\n      key: Math.random()\n    });\n    return _this;\n  }\n\n  /**\r\n   * Compatible React 16.3 -\r\n   * 兼容 React 16.3 - 版本\r\n   */\n\n  createClass(CacheComponent, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (!prevState.cached || !this.state.cached) {\n        return;\n      }\n      if (prevState.matched === true && this.state.matched === false) {\n        if (this.props.unmount) {\n          this.ejectDOM();\n        }\n        this.__cacheUpdateTime = Date.now();\n        ObjectValues(this.cacheLifecycles.__didCacheListener).forEach(function (func) {\n          run(func);\n        });\n        return run(this, 'cacheLifecycles.__listener.didCache');\n      }\n      if (prevState.matched === false && this.state.matched === true) {\n        if (this.props.saveScrollPosition) {\n          run(this.__revertScrollPos);\n        }\n        this.__cacheUpdateTime = Date.now();\n        ObjectValues(this.cacheLifecycles.__didRecoverListener).forEach(function (func) {\n          run(func);\n        });\n        return run(this, 'cacheLifecycles.__listener.didRecover');\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var willRecover = this.state.matched === false && nextState.matched === true;\n      var willDrop = this.state.cached === true && nextState.cached === false;\n      var shouldUpdate = this.state.matched || nextState.matched || this.state.cached !== nextState.cached;\n      if (shouldUpdate) {\n        if (this.props.unmount && willDrop || willRecover) {\n          this.injectDOM();\n        }\n        if (!(willDrop || willRecover) && this.props.saveScrollPosition) {\n          this.__revertScrollPos = saveScrollPosition(this.props.unmount ? this.wrapper : undefined);\n        }\n      }\n      return shouldUpdate;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _props = this.props,\n        unmount = _props.unmount,\n        href = _props.href,\n        multiple = _props.multiple;\n      var cacheKey = run(this.props, 'cacheKey', this.props);\n      if (multiple) {\n        var cache = _extends({}, getCache()[cacheKey]);\n        delete cache[href];\n        if (Object.keys(cache).length === 0) {\n          remove(cacheKey);\n        } else {\n          register(cacheKey, cache);\n        }\n      } else {\n        remove(cacheKey);\n      }\n      if (unmount) {\n        this.injectDOM();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n      var _state = this.state,\n        matched = _state.matched,\n        cached = _state.cached,\n        key = _state.key;\n      var _props2 = this.props,\n        _props2$className = _props2.className,\n        propsClassName = _props2$className === undefined ? '' : _props2$className,\n        behavior = _props2.behavior,\n        children = _props2.children;\n      var _value = value(run(behavior, undefined, !matched), {}),\n        _value$className = _value.className,\n        behaviorClassName = _value$className === undefined ? '' : _value$className,\n        behaviorProps = objectWithoutProperties(_value, ['className']);\n      var className = run(propsClassName + ' ' + behaviorClassName, 'trim');\n      var hasClassName = className !== '';\n      return cached ? React__default.createElement('div', _extends({\n        key: key,\n        className: hasClassName ? className : undefined\n      }, behaviorProps, {\n        ref: function ref(wrapper) {\n          _this2.wrapper = wrapper;\n        }\n      }), React__default.createElement(Provider, {\n        value: this.cacheLifecycles\n      }, run(children, undefined, this.cacheLifecycles))) : null;\n    }\n  }]);\n  return CacheComponent;\n}(React.Component);\nCacheComponent.__name = 'CacheComponent';\nCacheComponent.propsTypes = {\n  history: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  children: PropTypes.func.isRequired,\n  className: PropTypes.string,\n  when: PropTypes.oneOfType([PropTypes.func, PropTypes.oneOf(['forward', 'back', 'always'])]),\n  behavior: PropTypes.func,\n  unmount: PropTypes.bool,\n  saveScrollPosition: PropTypes.bool\n};\nCacheComponent.defaultProps = {\n  when: 'forward',\n  unmount: false,\n  saveScrollPosition: false,\n  behavior: function behavior(cached) {\n    return cached ? {\n      style: {\n        display: 'none'\n      }\n    } : undefined;\n  }\n};\nCacheComponent.getDerivedStateFromProps = isUsingNewLifecycle ? getDerivedStateFromProps : undefined;\n\n// Fork from react-freeze\n\nvar isSupported = isFunction(React.lazy) && !isUndefined(React.Suspense);\nvar notSupportSuspense = !isSupported;\nvar Suspender = function (_Component) {\n  inherits(Suspender, _Component);\n  function Suspender() {\n    var _ref;\n    var _temp, _this, _ret;\n    classCallCheck(this, Suspender);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Suspender.__proto__ || Object.getPrototypeOf(Suspender)).call.apply(_ref, [this].concat(args))), _this), _this.promiseCache = {}, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  createClass(Suspender, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n        freeze = _props.freeze,\n        children = _props.children;\n      var promiseCache = this.promiseCache;\n      if (freeze && !promiseCache.promise) {\n        promiseCache.promise = new Promise(function (resolve) {\n          promiseCache.resolve = resolve;\n        });\n        throw promiseCache.promise;\n      } else if (freeze) {\n        throw promiseCache.promise;\n      } else if (promiseCache.promise) {\n        promiseCache.resolve();\n        promiseCache.promise = undefined;\n      }\n      return React__default.createElement(React.Fragment, null, children);\n    }\n  }]);\n  return Suspender;\n}(React.Component);\nfunction Freeze(_ref2) {\n  var freeze = _ref2.freeze,\n    children = _ref2.children,\n    _ref2$placeholder = _ref2.placeholder,\n    placeholder = _ref2$placeholder === undefined ? null : _ref2$placeholder;\n  if (notSupportSuspense) return children;\n  return React__default.createElement(React.Suspense, {\n    fallback: placeholder\n  }, React__default.createElement(Suspender, {\n    freeze: freeze\n  }, children));\n}\nvar isSusSupported = !!React.Suspense;\nvar Freeze$1 = isSusSupported ? Freeze : function (_ref) {\n  var children = _ref.children;\n  return children;\n};\nvar DelayFreeze = function (_Component) {\n  inherits(DelayFreeze, _Component);\n  function DelayFreeze(props) {\n    classCallCheck(this, DelayFreeze);\n    var _this = possibleConstructorReturn(this, (DelayFreeze.__proto__ || Object.getPrototypeOf(DelayFreeze)).call(this, props));\n    _this.state = {\n      freeze: false\n    };\n    _this.freezeTimeout = null;\n    _this.shouldComponentUpdate = function (_ref2) {\n      var freeze = _ref2.freeze;\n      var currentFreeze = _this.props.freeze;\n      if (freeze !== currentFreeze) {\n        clearTimeout(_this.freezeTimeout);\n        _this.freezeTimeout = setTimeout(function () {\n          _this.setState({\n            freeze: freeze\n          });\n        }, 1000);\n      }\n      return true;\n    };\n    _this.render = function () {\n      return React__default.createElement(Freeze$1, {\n        freeze: !_this.props.freeze ? false : _this.state.freeze\n      }, run(_this.props, 'children'));\n    };\n    _this.state = {\n      freeze: props.freeze\n    };\n    return _this;\n  }\n  return DelayFreeze;\n}(React.Component);\nDelayFreeze.propsTypes = {\n  freeze: PropTypes.bool.isRequired\n};\nvar Updatable = function (_Component2) {\n  inherits(Updatable, _Component2);\n  function Updatable() {\n    var _ref3;\n    var _temp, _this2, _ret;\n    classCallCheck(this, Updatable);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this2 = possibleConstructorReturn(this, (_ref3 = Updatable.__proto__ || Object.getPrototypeOf(Updatable)).call.apply(_ref3, [this].concat(args))), _this2), _this2.render = function () {\n      return run(_this2.props, 'children');\n    }, _this2.shouldComponentUpdate = function (_ref4) {\n      var when = _ref4.when;\n      return when;\n    }, _temp), possibleConstructorReturn(_this2, _ret);\n  }\n  return Updatable;\n}(React.Component);\nUpdatable.propsTypes = {\n  when: PropTypes.bool.isRequired\n};\nvar Updatable$1 = function (_ref5) {\n  var _ref5$autoFreeze = _ref5.autoFreeze,\n    autoFreeze = _ref5$autoFreeze === undefined ? true : _ref5$autoFreeze,\n    props = objectWithoutProperties(_ref5, ['autoFreeze']);\n  return React__default.createElement(DelayFreeze, {\n    freeze: autoFreeze && !props.when\n  }, React__default.createElement(Updatable, props));\n};\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return React__default.Children.count(children) === 0;\n};\nvar isFragmentable = isExist(React.Fragment);\nvar CacheRoute = function (_Component) {\n  inherits(CacheRoute, _Component);\n  function CacheRoute() {\n    var _ref;\n    var _temp, _this, _ret;\n    classCallCheck(this, CacheRoute);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = CacheRoute.__proto__ || Object.getPrototypeOf(CacheRoute)).call.apply(_ref, [this].concat(args))), _this), _this.cache = {}, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  createClass(CacheRoute, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n      var _props = this.props,\n        children = _props.children,\n        render = _props.render,\n        component = _props.component,\n        className = _props.className,\n        when = _props.when,\n        behavior = _props.behavior,\n        cacheKey = _props.cacheKey,\n        unmount = _props.unmount,\n        saveScrollPosition$$1 = _props.saveScrollPosition,\n        computedMatchForCacheRoute = _props.computedMatchForCacheRoute,\n        multiple = _props.multiple,\n        autoFreeze = _props.autoFreeze,\n        restProps = objectWithoutProperties(_props, ['children', 'render', 'component', 'className', 'when', 'behavior', 'cacheKey', 'unmount', 'saveScrollPosition', 'computedMatchForCacheRoute', 'multiple', 'autoFreeze']);\n\n      /**\r\n       * Note:\r\n       * If children prop is a React Element, define the corresponding wrapper component for supporting multiple children\r\n       *\r\n       * 说明：如果 children 属性是 React Element 则定义对应的包裹组件以支持多个子组件\r\n       */\n\n      if (React__default.isValidElement(children) || !isEmptyChildren(children)) {\n        render = function render() {\n          return children;\n        };\n      }\n      if (computedMatchForCacheRoute) {\n        restProps.computedMatch = computedMatchForCacheRoute;\n      }\n      if (multiple && !isFragmentable) {\n        multiple = false;\n      }\n      if (isNumber(multiple)) {\n        multiple = clamp(multiple, 1);\n      }\n      return (\n        /**\r\n         * Only children prop of Route can help to control rendering behavior\r\n         * 只有 Router 的 children 属性有助于主动控制渲染行为\r\n         */\n        React__default.createElement(reactRouterDom.Route, restProps, function (props) {\n          var match = props.match,\n            computedMatch = props.computedMatch,\n            location = props.location;\n          var isMatchCurrentRoute = isMatch(props.match);\n          var currentPathname = location.pathname,\n            currentSearch = location.search;\n          var maxMultipleCount = isNumber(multiple) ? multiple : Infinity;\n          var configProps = {\n            when: when,\n            className: className,\n            behavior: behavior,\n            cacheKey: cacheKey,\n            unmount: unmount,\n            saveScrollPosition: saveScrollPosition$$1\n          };\n          var renderSingle = function renderSingle(props) {\n            return React__default.createElement(CacheComponent, props, function (cacheLifecycles) {\n              return React__default.createElement(Updatable$1, {\n                when: isMatch(props.match),\n                autoFreeze: autoFreeze\n              }, function () {\n                Object.assign(props, {\n                  cacheLifecycles: cacheLifecycles\n                });\n                if (component) {\n                  return React__default.createElement(component, props);\n                }\n                return run(render || children, undefined, props);\n              });\n            });\n          };\n          if (multiple && isMatchCurrentRoute) {\n            var multipleCacheKey = currentPathname + currentSearch;\n            _this2.cache[multipleCacheKey] = {\n              updateTime: Date.now(),\n              href: multipleCacheKey,\n              pathname: currentPathname,\n              render: renderSingle\n            };\n            Object.entries(_this2.cache).sort(function (_ref2, _ref3) {\n              var _ref5 = slicedToArray(_ref2, 2),\n                prev = _ref5[1];\n              var _ref4 = slicedToArray(_ref3, 2),\n                next = _ref4[1];\n              return next.updateTime - prev.updateTime;\n            }).forEach(function (_ref6, idx) {\n              var _ref7 = slicedToArray(_ref6, 1),\n                multipleCacheKey = _ref7[0];\n              if (idx >= maxMultipleCount) {\n                delete _this2.cache[multipleCacheKey];\n              }\n            });\n          }\n          return multiple ? React__default.createElement(React.Fragment, null, Object.entries(_this2.cache).map(function (_ref8) {\n            var _ref9 = slicedToArray(_ref8, 2),\n              multipleCacheKey = _ref9[0],\n              _ref9$ = _ref9[1],\n              render = _ref9$.render,\n              href = _ref9$.href,\n              pathname = _ref9$.pathname;\n            var recomputedMatch = multipleCacheKey === currentPathname + currentSearch ? match || computedMatch : null;\n            return React__default.createElement(React.Fragment, {\n              key: multipleCacheKey\n            }, render(_extends({}, props, configProps, {\n              cacheKey: cacheKey,\n              pathname: pathname,\n              href: href,\n              multiple: true,\n              key: multipleCacheKey,\n              match: recomputedMatch\n            })));\n          })) : renderSingle(_extends({}, props, configProps, {\n            pathname: currentPathname,\n            href: currentPathname,\n            multiple: false\n          }));\n        })\n      );\n    }\n  }]);\n  return CacheRoute;\n}(React.Component);\nCacheRoute.__name = 'CacheRoute';\nCacheRoute.propTypes = {\n  component: PropTypes.elementType || PropTypes.any,\n  render: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  computedMatchForCacheRoute: PropTypes.object,\n  multiple: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  autoFreeze: PropTypes.bool\n};\nCacheRoute.defaultProps = {\n  multiple: false\n};\nfunction getFragment() {\n  if (isExist(React.Fragment)) {\n    return function (_ref) {\n      var children = _ref.children;\n      return React__default.createElement(React.Fragment, null, children);\n    };\n  }\n  if (isExist(React.PropTypes)) {\n    return function (_ref2) {\n      var children = _ref2.children;\n      return React__default.createElement('div', null, children);\n    };\n  }\n  return function (_ref3) {\n    var children = _ref3.children;\n    return children;\n  };\n}\nvar SwitchFragment = getFragment();\nSwitchFragment.displayName = 'SwitchFragment';\nvar isUsingNewContext = isExist(reactRouterDom.__RouterContext) || isExist(reactRouterDom.useHistory);\nvar CacheSwitch = function (_Switch) {\n  inherits(CacheSwitch, _Switch);\n  function CacheSwitch() {\n    var _ref;\n    var _temp, _this, _ret;\n    classCallCheck(this, CacheSwitch);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = CacheSwitch.__proto__ || Object.getPrototypeOf(CacheSwitch)).call.apply(_ref, [this].concat(args))), _this), _this.getContext = function () {\n      if (isUsingNewContext) {\n        var _this$props = _this.props,\n          location = _this$props.location,\n          match = _this$props.match;\n        return {\n          location: location,\n          match: match\n        };\n      } else {\n        var route = _this.context.router.route;\n        var _location = _this.props.location || route.location;\n        return {\n          location: _location,\n          match: route.match\n        };\n      }\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  createClass(CacheSwitch, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n        children = _props.children,\n        which = _props.which,\n        autoFreeze = _props.autoFreeze;\n      var _getContext = this.getContext(),\n        location = _getContext.location,\n        contextMatch = _getContext.match;\n      var __matchedAlready = false;\n      return React__default.createElement(Updatable$1, {\n        when: isMatch(contextMatch),\n        autoFreeze: autoFreeze\n      }, function () {\n        return React__default.createElement(SwitchFragment, null, React__default.Children.map(children, function (element) {\n          if (!React__default.isValidElement(element)) {\n            return null;\n          }\n          var path = element.props.path || element.props.from;\n          var match = __matchedAlready ? null : path ? reactRouterDom.matchPath(location.pathname, _extends({}, element.props, {\n            path: path\n          }), contextMatch) : contextMatch;\n          var child = void 0;\n          if (which(element)) {\n            child = React__default.cloneElement(element, _extends({\n              location: location,\n              computedMatch: match\n            }, isNull(match) ? {\n              computedMatchForCacheRoute: defineProperty({}, COMPUTED_UNMATCH_KEY, true)\n            } : null));\n          } else {\n            child = match && !__matchedAlready ? React__default.cloneElement(element, {\n              location: location,\n              computedMatch: match\n            }) : null;\n          }\n          if (!__matchedAlready) {\n            __matchedAlready = !!match;\n          }\n          return child;\n        }));\n      });\n    }\n  }]);\n  return CacheSwitch;\n}(reactRouterDom.Switch);\nif (isUsingNewContext) {\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object.isRequired,\n    match: PropTypes.object.isRequired,\n    which: PropTypes.func\n  };\n  CacheSwitch = reactRouterDom.withRouter(CacheSwitch);\n} else {\n  CacheSwitch.contextTypes = {\n    router: PropTypes.shape({\n      route: PropTypes.object.isRequired\n    }).isRequired\n  };\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object,\n    which: PropTypes.func\n  };\n}\nCacheSwitch.defaultProps = {\n  which: function which(element) {\n    return get(element, 'type.__name') === 'CacheRoute';\n  }\n};\nvar CacheSwitch$1 = CacheSwitch;\nexports.default = CacheRoute;\nexports.CacheRoute = CacheRoute;\nexports.CacheSwitch = CacheSwitch$1;\nexports.dropByCacheKey = dropByCacheKey;\nexports.refreshByCacheKey = refreshByCacheKey;\nexports.getCachingKeys = getCachingKeys;\nexports.clearCache = clearCache;\nexports.getCachingComponents = getCachingComponents;\nexports.useDidCache = useDidCache;\nexports.useDidRecover = useDidRecover;","map":{"version":3,"names":["isUndefined","val","isNull","isFunction","isString","isExist","isArray","Array","isNaN","isNumber","get","obj","keys","arguments","length","undefined","defaultValue","String","result","split","reduce","res","key","e","run","args","_len","_key","func","context","slice","call","apply","concat","value","values","_len2","_key2","nextValue","getImplementation","self","window","global","Error","implementation","getGlobal","_typeof","Math","globalThis","flatten","array","item","toConsumableArray","clamp","min","max","Number","MAX_VALUE","ObjectValues","object","push","body","screenScrollingElement","isScrollableNode","node","scrollWidth","clientWidth","scrollHeight","clientHeight","getScrollableNodes","from","filter","saveScrollPosition","nodes","Set","map","saver","scrollLeft","scrollTop","revert","forEach","_ref","_ref2","x","_ref2$","y","__components","getCachedComponentEntries","Object","entries","cache","CacheComponent","state","cached","some","getCache","register","component","remove","dropComponent","dropByCacheKey","refreshComponent","refreshByCacheKey","clearCache","_ref3","_ref4","getCachingKeys","_ref5","_ref6","getCachingComponents","_ref7","_ref8","defineProperty","_ref10","pathname","_ref11","createContext","Provider","Consumer","useCacheRoute","lifecycleName","effect","React","useContext","effectRef","useRef","current","cacheLifecycles","off","useDidCache","bind","useDidRecover","isUsingNewLifecycle","React__default","forwardRef","COMPUTED_UNMATCH_KEY","isMatch","match","getDerivedStateFromProps","nextProps","prevState","nextPropsMatch","when","_nextProps$when","matched","nextAction","__cancel__cache","includes","_Component","props","on","eventName","id","random","listenerKey","_this","didCache","listener","__listener","didRecover","componentWillReceiveProps","nextState","setState","injectDOM","__parentNode","wrapper","__placeholderNode","err","ejectDOM","parentNode","reset","__revertScrollPos","refresh","__cacheCreateTime","Date","now","__cacheUpdateTime","cacheKey","multiple","href","_extends","document","_cacheKey","createComment","prevProps","unmount","__didCacheListener","__didRecoverListener","willRecover","willDrop","shouldUpdate","_props","_state","className","propsClassName","_props2$className","behavior","_props2","children","behaviorClassName","_value$className","behaviorProps","objectWithoutProperties","_value","hasClassName","createElement","ref","Component","__name","propsTypes","PropTypes","isRequired","string","oneOfType","oneOf","bool","defaultProps","isSupported","lazy","Suspense","notSupportSuspense","Suspender","promiseCache","_temp","possibleConstructorReturn","_ret","freeze","promise","Promise","resolve","Freeze","placeholder","_ref2$placeholder","fallback","isSusSupported","Freeze$1","DelayFreeze","freezeTimeout","shouldComponentUpdate","currentFreeze","setTimeout","render","Updatable","_Component2","_this2","Updatable$1","autoFreeze","_ref5$autoFreeze","isEmptyChildren","Children","count","isFragmentable","Fragment","CacheRoute","saveScrollPosition$$1","computedMatchForCacheRoute","restProps","isValidElement","computedMatch","location","isMatchCurrentRoute","currentPathname","currentSearch","search","maxMultipleCount","Infinity","configProps","renderSingle","assign","multipleCacheKey","sort","prev","next","updateTime","idx","_ref9","_ref9$","recomputedMatch","propTypes","elementType","any","number","getFragment","SwitchFragment","displayName","isUsingNewContext","reactRouterDom","__RouterContext","useHistory","CacheSwitch","_Switch","getContext","_this$props","route","router","_location","which","_getContext","contextMatch","__matchedAlready","element","path","matchPath","child","cloneElement","Switch","withRouter","contextTypes","shape","CacheSwitch$1"],"sources":["/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/helpers/base/is.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/helpers/base/try/index.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/helpers/base/globalThis.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/helpers/utils.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/helpers/saveScrollPosition.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/core/manager.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/core/context.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/core/CacheComponent.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/core/Updatable/Freeze.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/core/Updatable/index.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/components/CacheRoute.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/components/SwitchFragment.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-router-cache-route/src/components/CacheSwitch.js"],"sourcesContent":["// 值类型判断 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nexport const isUndefined = val => typeof val === 'undefined'\n\nexport const isNull = val => val === null\n\nexport const isFunction = val => typeof val === 'function'\n\nexport const isString = val => typeof val === 'string'\n\nexport const isExist = val => !(isUndefined(val) || isNull(val))\n\nexport const isArray = val => val instanceof Array\n\nexport const isNaN = val => val !== val\n\nexport const isNumber = val => typeof val === 'number' && !isNaN(val)\n// 值类型判断 -------------------------------------------------------------\n","import { isString, isExist, isUndefined, isFunction, isNumber } from '../is'\n\nexport const get = (obj, keys = [], defaultValue) => {\n  try {\n    if (isNumber(keys)) {\n      keys = String(keys)\n    }\n    let result = (isString(keys) ? keys.split('.') : keys).reduce(\n      (res, key) => res[key],\n      obj\n    )\n    return isUndefined(result) ? defaultValue : result\n  } catch (e) {\n    return defaultValue\n  }\n}\n\nexport const run = (obj, keys = [], ...args) => {\n  keys = isString(keys) ? keys.split('.') : keys\n\n  const func = get(obj, keys)\n  const context = get(obj, keys.slice(0, -1))\n\n  return isFunction(func) ? func.call(context, ...args) : func\n}\n\nexport const value = (...values) =>\n  values.reduce(\n    (value, nextValue) => (isUndefined(value) ? run(nextValue) : run(value)),\n    undefined\n  )\n","const getImplementation = () => {\n  if (typeof self !== 'undefined') {\n    return self\n  }\n  if (typeof window !== 'undefined') {\n    return window\n  }\n  if (typeof global !== 'undefined') {\n    return global\n  }\n\n  throw new Error('unable to locate global object')\n}\n\nconst implementation = getImplementation()\n\nconst getGlobal = () => {\n  if (\n    typeof global !== 'object' ||\n    !global ||\n    global.Math !== Math ||\n    global.Array !== Array\n  ) {\n    return implementation\n  }\n  return global\n}\n\nconst globalThis = getGlobal()\n\nexport default globalThis\n","import { isArray } from './base/is'\n\nexport const nextTick = func => Promise.resolve().then(func)\n\nexport const flatten = array =>\n  array.reduce(\n    (res, item) => [...res, ...(isArray(item) ? flatten(item) : [item])],\n    []\n  )\n\n/**\n * [钳子] 用来将数字限制在给定范围内\n * @param {Number} value 被限制值\n * @param {Number} min 最小值\n * @param {Number} max 最大值\n */\nexport const clamp = (value, min, max = Number.MAX_VALUE) => {\n  if (value < min) {\n    return min\n  }\n\n  if (value > max) {\n    return max\n  }\n\n  return value\n}\n\nexport const ObjectValues = (object) => {\n  const res = []\n  for (let key in object) {\n    res.push(object[key])\n  }\n  return res\n}\n","import root from './base/globalThis'\nimport { get, run, value } from './base/try'\nimport { isArray, isFunction, isExist } from './base/is'\nimport { flatten } from './utils'\n\nconst body = get(root, 'document.body')\nconst screenScrollingElement = get(\n  root,\n  'document.scrollingElement',\n  get(root, 'document.documentElement', {})\n)\n\nfunction isScrollableNode(node = {}) {\n  if (!isExist(node)) {\n    return false\n  }\n\n  return (\n    node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight\n  )\n}\n\nfunction getScrollableNodes(from) {\n  if (!isFunction(get(root, 'document.getElementById'))) {\n    return []\n  }\n\n  return [...value(run(from, 'querySelectorAll', '*'), []), from].filter(\n    isScrollableNode\n  )\n}\n\nexport default function saveScrollPosition(from) {\n  const nodes = [\n    ...new Set([\n      ...flatten((!isArray(from) ? [from] : from).map(getScrollableNodes)),\n      ...[screenScrollingElement, body].filter(isScrollableNode)\n    ])\n  ]\n\n  const saver = nodes.map(node => [\n    node,\n    {\n      x: node.scrollLeft,\n      y: node.scrollTop\n    }\n  ])\n\n  return function revert() {\n    saver.forEach(([node, { x, y }]) => {\n      node.scrollLeft = x\n      node.scrollTop = y\n    })\n  }\n}\n","import CacheComponent from './CacheComponent'\nimport { get, run } from '../helpers'\n\nconst __components = {}\n\nconst getCachedComponentEntries = () =>\n  Object.entries(__components).filter(\n    ([, cache]) =>\n      cache instanceof CacheComponent\n        ? cache.state.cached\n        : Object.values(cache).some(cache => cache.state.cached)\n  )\n\nexport const getCache = () => ({ ...__components })\n\nexport const register = (key, component) => {\n  __components[key] = component\n}\n\nexport const remove = key => {\n  delete __components[key]\n}\n\nconst dropComponent = component => run(component, 'reset')\n\nexport const dropByCacheKey = key => {\n  const cache = get(__components, [key])\n\n  if (!cache) {\n    return\n  }\n\n  if (cache instanceof CacheComponent) {\n    dropComponent(cache)\n  } else {\n    Object.values(cache).forEach(dropComponent)\n  }\n}\n\nconst refreshComponent = component => run(component, 'refresh');\n\nexport const refreshByCacheKey = key => {\n  const cache = get(__components, [key]);\n\n  if (!cache) {\n    return;\n  }\n\n  if (cache instanceof CacheComponent) {\n    refreshComponent(cache);\n  } else {\n    Object.values(cache).forEach(refreshComponent);\n  }\n};\n\nexport const clearCache = () => {\n  getCachedComponentEntries().forEach(([key]) => dropByCacheKey(key))\n}\n\nexport const getCachingKeys = () =>\n  getCachedComponentEntries().map(([key]) => key)\n\nexport const getCachingComponents = () =>\n  getCachedComponentEntries().reduce(\n    (res, [key, cache]) => ({\n      ...res,\n      ...(cache instanceof CacheComponent\n        ? { [key]: cache }\n        : Object.entries(cache).reduce(\n            (res, [pathname, cache]) => ({\n              ...res,\n              [`${key}.${pathname}`]: cache\n            }),\n            {}\n          ))\n    }),\n    {}\n  )\n","import { useEffect, useContext, useRef } from 'react'\nimport createContext from 'mini-create-react-context'\n\nimport { isArray, isFunction, run } from '../helpers'\n\nconst context = createContext()\n\nexport default context\nexport const { Provider, Consumer } = context\n\nfunction useCacheRoute(lifecycleName, effect, deps = []) {\n  if (!isFunction(useContext)) {\n    return\n  }\n\n  const effectRef = useRef(() => null)\n  effectRef.current = effect\n\n  const cacheLifecycles = useContext(context)\n  useEffect(() => {\n    const off = run(cacheLifecycles, 'on', lifecycleName, () => {\n      run(effectRef.current)\n    })\n\n    return () => run(off)\n  }, [])\n}\nexport const useDidCache = useCacheRoute.bind(null, 'didCache')\nexport const useDidRecover = useCacheRoute.bind(null, 'didRecover')\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport {\r\n  run,\r\n  get,\r\n  value,\r\n  isExist,\r\n  isFunction,\r\n  saveScrollPosition,\r\n  ObjectValues\r\n} from '../helpers'\r\nimport * as manager from './manager'\r\nimport { Provider as CacheRouteProvider } from './context'\r\n\r\nconst isUsingNewLifecycle = isExist(React.forwardRef)\r\n\r\nexport const COMPUTED_UNMATCH_KEY = '__isComputedUnmatch'\r\nexport const isMatch = match =>\r\n  isExist(match) && get(match, COMPUTED_UNMATCH_KEY) !== true\r\n\r\nconst getDerivedStateFromProps = (nextProps, prevState) => {\r\n  let { match: nextPropsMatch, when = 'forward' } = nextProps\r\n\r\n  /**\r\n   * Note:\r\n   * Turn computedMatch from CacheSwitch to a real null value\r\n   *\r\n   * 将 CacheSwitch 计算得到的 computedMatch 值转换为真正的 null\r\n   */\r\n  if (!isMatch(nextPropsMatch)) {\r\n    nextPropsMatch = null\r\n  }\r\n\r\n  if (!prevState.cached && nextPropsMatch) {\r\n    return {\r\n      cached: true,\r\n      matched: true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determines whether it needs to cancel the cache based on the next unmatched props action\r\n   *\r\n   * 根据下个未匹配状态动作决定是否需要取消缓存\r\n   */\r\n  if (prevState.matched && !nextPropsMatch) {\r\n    const nextAction = get(nextProps, 'history.action')\r\n\r\n    let __cancel__cache = false\r\n\r\n    if (isFunction(when)) {\r\n      __cancel__cache = !when(nextProps)\r\n    } else {\r\n      switch (when) {\r\n        case 'always':\r\n          break\r\n        case 'back':\r\n          if (['PUSH', 'REPLACE'].includes(nextAction)) {\r\n            __cancel__cache = true\r\n          }\r\n\r\n          break\r\n        case 'forward':\r\n        default:\r\n          if (nextAction === 'POP') {\r\n            __cancel__cache = true\r\n          }\r\n      }\r\n    }\r\n\r\n    if (__cancel__cache) {\r\n      return {\r\n        cached: false,\r\n        matched: false\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    matched: !!nextPropsMatch\r\n  }\r\n}\r\n\r\nexport default class CacheComponent extends Component {\r\n  static __name = 'CacheComponent'\r\n\r\n  static propsTypes = {\r\n    history: PropTypes.object.isRequired,\r\n    match: PropTypes.object.isRequired,\r\n    children: PropTypes.func.isRequired,\r\n    className: PropTypes.string,\r\n    when: PropTypes.oneOfType([\r\n      PropTypes.func,\r\n      PropTypes.oneOf(['forward', 'back', 'always'])\r\n    ]),\r\n    behavior: PropTypes.func,\r\n    unmount: PropTypes.bool,\r\n    saveScrollPosition: PropTypes.bool\r\n  }\r\n\r\n  static defaultProps = {\r\n    when: 'forward',\r\n    unmount: false,\r\n    saveScrollPosition: false,\r\n    behavior: cached =>\r\n      cached\r\n        ? {\r\n            style: {\r\n              display: 'none'\r\n            }\r\n          }\r\n        : undefined\r\n  }\r\n\r\n  constructor(props, ...args) {\r\n    super(props, ...args)\r\n\r\n    this.__cacheCreateTime = Date.now()\r\n    this.__cacheUpdateTime = this.__cacheCreateTime\r\n    if (props.cacheKey) {\r\n      const cacheKey = run(props.cacheKey, undefined, props)\r\n      if (props.multiple) {\r\n        const { href } = props\r\n        manager.register(cacheKey, {\r\n          ...manager.getCache()[cacheKey],\r\n          [href]: this\r\n        })\r\n      } else {\r\n        manager.register(cacheKey, this)\r\n      }\r\n    }\r\n\r\n    if (typeof document !== 'undefined') {\r\n      const cacheKey = run(props.cacheKey, undefined, props)\r\n      this.__placeholderNode = document.createComment(\r\n        ` Route cached ${cacheKey ? `with cacheKey: \"${cacheKey}\" ` : ''}`\r\n      )\r\n    }\r\n\r\n    this.state = getDerivedStateFromProps(props, {\r\n      cached: false,\r\n      matched: false,\r\n      key: Math.random()\r\n    })\r\n  }\r\n\r\n  cacheLifecycles = {\r\n    __listener: {},\r\n    __didCacheListener: {},\r\n    __didRecoverListener: {},\r\n    on: (eventName, func) => {\r\n      const id = Math.random()\r\n      const listenerKey = `__${eventName}Listener`\r\n      this.cacheLifecycles[listenerKey][id] = func\r\n\r\n      return () => {\r\n        delete this.cacheLifecycles[listenerKey][id]\r\n      }\r\n    },\r\n    didCache: listener => {\r\n      this.cacheLifecycles.__listener['didCache'] = listener\r\n    },\r\n    didRecover: listener => {\r\n      this.cacheLifecycles.__listener['didRecover'] = listener\r\n    }\r\n  }\r\n\r\n  /**\r\n   * New lifecycle for replacing the `componentWillReceiveProps` in React 16.3 +\r\n   * React 16.3 + 版本中替代 componentWillReceiveProps 的新生命周期\r\n   */\r\n  static getDerivedStateFromProps = isUsingNewLifecycle\r\n    ? getDerivedStateFromProps\r\n    : undefined\r\n\r\n  /**\r\n   * Compatible React 16.3 -\r\n   * 兼容 React 16.3 - 版本\r\n   */\r\n  componentWillReceiveProps = !isUsingNewLifecycle\r\n    ? nextProps => {\r\n        const nextState = getDerivedStateFromProps(nextProps, this.state)\r\n\r\n        this.setState(nextState)\r\n      }\r\n    : undefined\r\n\r\n  __parentNode\r\n  __placeholderNode\r\n  __revertScrollPos\r\n  injectDOM = () => {\r\n    try {\r\n      run(\r\n        this.__parentNode,\r\n        'insertBefore',\r\n        this.wrapper,\r\n        this.__placeholderNode\r\n      )\r\n      run(this.__parentNode, 'removeChild', this.__placeholderNode)\r\n    } catch (err) {\r\n      // nothing\r\n    }\r\n  }\r\n\r\n  ejectDOM = () => {\r\n    try {\r\n      const parentNode = get(this.wrapper, 'parentNode')\r\n      this.__parentNode = parentNode\r\n\r\n      run(\r\n        this.__parentNode,\r\n        'insertBefore',\r\n        this.__placeholderNode,\r\n        this.wrapper\r\n      )\r\n      run(this.__parentNode, 'removeChild', this.wrapper)\r\n    } catch (err) {\r\n      // nothing\r\n    }\r\n  }\r\n  componentDidUpdate(prevProps, prevState) {\r\n    if (!prevState.cached || !this.state.cached) {\r\n      return\r\n    }\r\n\r\n    if (prevState.matched === true && this.state.matched === false) {\r\n      if (this.props.unmount) {\r\n        this.ejectDOM()\r\n      }\r\n      this.__cacheUpdateTime = Date.now()\r\n      ObjectValues(this.cacheLifecycles.__didCacheListener).forEach(func => {\r\n        run(func)\r\n      })\r\n      return run(this, 'cacheLifecycles.__listener.didCache')\r\n    }\r\n\r\n    if (prevState.matched === false && this.state.matched === true) {\r\n      if (this.props.saveScrollPosition) {\r\n        run(this.__revertScrollPos)\r\n      }\r\n      this.__cacheUpdateTime = Date.now()\r\n      ObjectValues(this.cacheLifecycles.__didRecoverListener).forEach(func => {\r\n        run(func)\r\n      })\r\n      return run(this, 'cacheLifecycles.__listener.didRecover')\r\n    }\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    const willRecover =\r\n      this.state.matched === false && nextState.matched === true\r\n    const willDrop = this.state.cached === true && nextState.cached === false\r\n    const shouldUpdate =\r\n      this.state.matched ||\r\n      nextState.matched ||\r\n      this.state.cached !== nextState.cached\r\n\r\n    if (shouldUpdate) {\r\n      if ((this.props.unmount && willDrop) || willRecover) {\r\n        this.injectDOM()\r\n      }\r\n\r\n      if (!(willDrop || willRecover) && this.props.saveScrollPosition) {\r\n        this.__revertScrollPos = saveScrollPosition(\r\n          this.props.unmount ? this.wrapper : undefined\r\n        )\r\n      }\r\n    }\r\n\r\n    return shouldUpdate\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    const { unmount, href, multiple } = this.props\r\n    const cacheKey = run(this.props, 'cacheKey', this.props)\r\n\r\n    if (multiple) {\r\n      const cache = { ...manager.getCache()[cacheKey] }\r\n\r\n      delete cache[href]\r\n\r\n      if (Object.keys(cache).length === 0) {\r\n        manager.remove(cacheKey)\r\n      } else {\r\n        manager.register(cacheKey, cache)\r\n      }\r\n    } else {\r\n      manager.remove(cacheKey)\r\n    }\r\n\r\n    if (unmount) {\r\n      this.injectDOM()\r\n    }\r\n  }\r\n\r\n  reset = () => {\r\n    delete this.__revertScrollPos\r\n\r\n    this.setState({\r\n      cached: false\r\n    })\r\n  }\r\n\r\n  refresh = () => {\r\n    delete this.__revertScrollPos;\r\n\r\n    this.setState({\r\n      key: Math.random()\r\n    });\r\n  };\r\n\r\n  render() {\r\n    const { matched, cached, key } = this.state\r\n    const { className: propsClassName = '', behavior, children } = this.props\r\n    const { className: behaviorClassName = '', ...behaviorProps } = value(\r\n      run(behavior, undefined, !matched),\r\n      {}\r\n    )\r\n    const className = run(`${propsClassName} ${behaviorClassName}`, 'trim')\r\n    const hasClassName = className !== ''\r\n\r\n    return cached ? (\r\n      <div\r\n        key={key}\r\n        className={hasClassName ? className : undefined}\r\n        {...behaviorProps}\r\n        ref={wrapper => {\r\n          this.wrapper = wrapper\r\n        }}\r\n      >\r\n        <CacheRouteProvider value={this.cacheLifecycles}>\r\n          {run(children, undefined, this.cacheLifecycles)}\r\n        </CacheRouteProvider>\r\n      </div>\r\n    ) : null\r\n  }\r\n}\r\n","// Fork from react-freeze\r\n// https://github.com/software-mansion/react-freeze/blob/main/src/index.tsx\r\nimport React, { Component, lazy, Suspense, Fragment } from 'react'\r\nimport { globalThis, isUndefined, isFunction } from '../../helpers'\r\n\r\nconst isSupported = isFunction(lazy) && !isUndefined(Suspense)\r\nconst notSupportSuspense = !isSupported\r\n\r\nclass Suspender extends Component {\r\n  promiseCache = {}\r\n  render() {\r\n    const { freeze, children } = this.props\r\n    const { promiseCache } = this\r\n\r\n    if (freeze && !promiseCache.promise) {\r\n      promiseCache.promise = new Promise((resolve) => {\r\n        promiseCache.resolve = resolve\r\n      })\r\n      throw promiseCache.promise\r\n    } else if (freeze) {\r\n      throw promiseCache.promise\r\n    } else if (promiseCache.promise) {\r\n      promiseCache.resolve()\r\n      promiseCache.promise = undefined\r\n    }\r\n\r\n    return <Fragment>{children}</Fragment>\r\n  }\r\n}\r\n\r\nexport default function Freeze({ freeze, children, placeholder = null }) {\r\n  if (notSupportSuspense) return children\r\n\r\n  return (\r\n    <Suspense fallback={placeholder}>\r\n      <Suspender freeze={freeze}>{children}</Suspender>\r\n    </Suspense>\r\n  )\r\n}\r\n","import React, { Component, Suspense } from 'react'\nimport ReactFreeze from './Freeze'\nimport PropTypes from 'prop-types'\n\nimport { run, get } from '../../helpers'\n\nconst isSusSupported = !!Suspense\nconst Freeze = isSusSupported ? ReactFreeze : ({ children }) => children\n\nclass DelayFreeze extends Component {\n  static propsTypes = {\n    freeze: PropTypes.bool.isRequired\n  }\n  state = {\n    freeze: false,\n  }\n  constructor(props) {\n    super(props)\n    this.state = {\n      freeze: props.freeze,\n    }\n  }\n\n  freezeTimeout = null\n  shouldComponentUpdate = ({ freeze }) => {\n    const currentFreeze = this.props.freeze\n\n    if (freeze !== currentFreeze) {\n      clearTimeout(this.freezeTimeout)\n      this.freezeTimeout = setTimeout(() => {\n        this.setState({\n          freeze,\n        })\n      }, 1000)\n    }\n\n    return true\n  }\n  render = () => (\n    <Freeze freeze={!this.props.freeze ? false : this.state.freeze}>\n      {run(this.props, 'children')}\n    </Freeze>\n  )\n}\n\nclass Updatable extends Component {\n  static propsTypes = {\n    when: PropTypes.bool.isRequired,\n  }\n\n  render = () => run(this.props, 'children')\n  shouldComponentUpdate = ({ when }) => when\n}\n\nexport default ({ autoFreeze = true, ...props }) => (\n  <DelayFreeze freeze={autoFreeze && !props.when}>\n    <Updatable {...props} />\n  </DelayFreeze>\n)\n","import React, { Component, Fragment } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Route } from 'react-router-dom'\r\n\r\nimport CacheComponent, { isMatch } from '../core/CacheComponent'\r\nimport Updatable from '../core/Updatable'\r\nimport { run, isExist, isNumber, clamp } from '../helpers'\r\n\r\nconst isEmptyChildren = children => React.Children.count(children) === 0\r\nconst isFragmentable = isExist(Fragment)\r\n\r\nexport default class CacheRoute extends Component {\r\n  static __name = 'CacheRoute'\r\n\r\n  static propTypes = {\r\n    component: PropTypes.elementType || PropTypes.any,\r\n    render: PropTypes.func,\r\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\r\n    computedMatchForCacheRoute: PropTypes.object,\r\n    multiple: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\r\n    autoFreeze: PropTypes.bool\r\n  }\r\n\r\n  static defaultProps = {\r\n    multiple: false\r\n  }\r\n\r\n  cache = {}\r\n\r\n  render() {\r\n    let {\r\n      children,\r\n      render,\r\n      component,\r\n      className,\r\n      when,\r\n      behavior,\r\n      cacheKey,\r\n      unmount,\r\n      saveScrollPosition,\r\n      computedMatchForCacheRoute,\r\n      multiple,\r\n      autoFreeze,\r\n      ...restProps\r\n    } = this.props\r\n\r\n    /**\r\n     * Note:\r\n     * If children prop is a React Element, define the corresponding wrapper component for supporting multiple children\r\n     *\r\n     * 说明：如果 children 属性是 React Element 则定义对应的包裹组件以支持多个子组件\r\n     */\r\n    if (React.isValidElement(children) || !isEmptyChildren(children)) {\r\n      render = () => children\r\n    }\r\n\r\n    if (computedMatchForCacheRoute) {\r\n      restProps.computedMatch = computedMatchForCacheRoute\r\n    }\r\n\r\n    if (multiple && !isFragmentable) {\r\n      multiple = false\r\n    }\r\n\r\n    if (isNumber(multiple)) {\r\n      multiple = clamp(multiple, 1)\r\n    }\r\n\r\n    return (\r\n      /**\r\n       * Only children prop of Route can help to control rendering behavior\r\n       * 只有 Router 的 children 属性有助于主动控制渲染行为\r\n       */\r\n      <Route {...restProps}>\r\n        {props => {\r\n          const { match, computedMatch, location } = props\r\n          const isMatchCurrentRoute = isMatch(props.match)\r\n          const { pathname: currentPathname, search: currentSearch } = location\r\n          const maxMultipleCount = isNumber(multiple) ? multiple : Infinity\r\n          const configProps = {\r\n            when,\r\n            className,\r\n            behavior,\r\n            cacheKey,\r\n            unmount,\r\n            saveScrollPosition\r\n          }\r\n\r\n          const renderSingle = props => (\r\n            <CacheComponent {...props}>\r\n              {cacheLifecycles => (\r\n                <Updatable when={isMatch(props.match)} autoFreeze={autoFreeze}>\r\n                  {() => {\r\n                    Object.assign(props, { cacheLifecycles })\r\n\r\n                    if (component) {\r\n                      return React.createElement(component, props)\r\n                    }\r\n\r\n                    return run(render || children, undefined, props)\r\n                  }}\r\n                </Updatable>\r\n              )}\r\n            </CacheComponent>\r\n          )\r\n\r\n          if (multiple && isMatchCurrentRoute) {\r\n            const multipleCacheKey = currentPathname + currentSearch\r\n            this.cache[multipleCacheKey] = {\r\n              updateTime: Date.now(),\r\n              href: multipleCacheKey,\r\n              pathname: currentPathname,\r\n              render: renderSingle\r\n            }\r\n\r\n            Object.entries(this.cache)\r\n              .sort(([, prev], [, next]) => next.updateTime - prev.updateTime)\r\n              .forEach(([multipleCacheKey], idx) => {\r\n                if (idx >= maxMultipleCount) {\r\n                  delete this.cache[multipleCacheKey]\r\n                }\r\n              })\r\n          }\r\n\r\n          return multiple ? (\r\n            <Fragment>\r\n              {Object.entries(this.cache).map(([multipleCacheKey, { render, href, pathname }]) => {\r\n                const recomputedMatch =\r\n                  multipleCacheKey === currentPathname + currentSearch ? match || computedMatch : null\r\n\r\n                return (\r\n                  <Fragment key={multipleCacheKey}>\r\n                    {render({\r\n                      ...props,\r\n                      ...configProps,\r\n                      cacheKey,\r\n                      pathname,\r\n                      href,\r\n                      multiple: true,\r\n                      key: multipleCacheKey,\r\n                      match: recomputedMatch\r\n                    })}\r\n                  </Fragment>\r\n                )\r\n              })}\r\n            </Fragment>\r\n          ) : (\r\n            renderSingle({\r\n              ...props,\r\n              ...configProps,\r\n              pathname: currentPathname,\r\n              href: currentPathname,\r\n              multiple: false\r\n            })\r\n          )\r\n        }}\r\n      </Route>\r\n    )\r\n  }\r\n}\r\n","import React, { PropTypes, Fragment } from 'react'\n\nimport { isExist } from '../helpers'\n\nfunction getFragment() {\n  if (isExist(Fragment)) {\n    return ({ children }) => <Fragment>{children}</Fragment>\n  }\n\n  if (isExist(PropTypes)) {\n    return ({ children }) => <div>{children}</div>\n  }\n\n  return ({ children }) => children\n}\n\nconst SwitchFragment = getFragment()\nSwitchFragment.displayName = 'SwitchFragment'\n\nexport default SwitchFragment\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Switch,\n  matchPath,\n  withRouter,\n  useHistory,\n  __RouterContext\n} from 'react-router-dom'\n\nimport { COMPUTED_UNMATCH_KEY, isMatch } from '../core/CacheComponent'\nimport Updatable from '../core/Updatable'\nimport SwitchFragment from './SwitchFragment'\nimport { get, isNull, isExist } from '../helpers'\n\nconst isUsingNewContext = isExist(__RouterContext) || isExist(useHistory)\n\nclass CacheSwitch extends Switch {\n  getContext = () => {\n    if (isUsingNewContext) {\n      const { location, match } = this.props\n\n      return { location, match }\n    } else {\n      const { route } = this.context.router\n      const location = this.props.location || route.location\n\n      return {\n        location,\n        match: route.match\n      }\n    }\n  }\n\n  render() {\n    const { children, which, autoFreeze } = this.props\n    const { location, match: contextMatch } = this.getContext()\n\n    let __matchedAlready = false\n\n    return (\n      <Updatable when={isMatch(contextMatch)} autoFreeze={autoFreeze}>\n        {() => (\n          <SwitchFragment>\n            {React.Children.map(children, element => {\n              if (!React.isValidElement(element)) {\n                return null\n              }\n\n              const path = element.props.path || element.props.from\n              const match = __matchedAlready\n                ? null\n                : path\n                  ? matchPath(\n                      location.pathname,\n                      {\n                        ...element.props,\n                        path\n                      },\n                      contextMatch\n                    )\n                  : contextMatch\n\n              let child\n\n              if (which(element)) {\n                child = React.cloneElement(element, {\n                  location,\n                  computedMatch: match,\n                  /**\n                   * https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js#L57\n                   *\n                   * Note:\n                   * Route would use computedMatch as its next match state ONLY when computedMatch is a true value\n                   * So here we have to do some trick to let the unmatch result pass Route's computedMatch check\n                   *\n                   * 注意：只有当 computedMatch 为真值时，Route 才会使用 computedMatch 作为其下一个匹配状态\n                   * 所以这里我们必须做一些手脚，让 unmatch 结果通过 Route 的 computedMatch 检查\n                   */\n                  ...(isNull(match)\n                    ? {\n                        computedMatchForCacheRoute: {\n                          [COMPUTED_UNMATCH_KEY]: true\n                        }\n                      }\n                    : null)\n                })\n              } else {\n                child =\n                  match && !__matchedAlready\n                    ? React.cloneElement(element, {\n                        location,\n                        computedMatch: match\n                      })\n                    : null\n              }\n\n              if (!__matchedAlready) {\n                __matchedAlready = !!match\n              }\n\n              return child\n            })}\n          </SwitchFragment>\n        )}\n      </Updatable>\n    )\n  }\n}\n\nif (isUsingNewContext) {\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object.isRequired,\n    match: PropTypes.object.isRequired,\n    which: PropTypes.func\n  }\n\n  CacheSwitch = withRouter(CacheSwitch)\n} else {\n  CacheSwitch.contextTypes = {\n    router: PropTypes.shape({\n      route: PropTypes.object.isRequired\n    }).isRequired\n  }\n\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object,\n    which: PropTypes.func\n  }\n}\n\nCacheSwitch.defaultProps = {\n  which: element => get(element, 'type.__name') === 'CacheRoute'\n}\n\nexport default CacheSwitch\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}