{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar _run = _interopDefault(require('szfe-tools/lib/run'));\nvar react = require('react');\nvar _isFunction = _interopDefault(require('szfe-tools/lib/isFunction'));\nvar _isString = _interopDefault(require('szfe-tools/lib/isString'));\nvar _get = _interopDefault(require('szfe-tools/lib/get'));\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction getKey2Id() {\n  var uuid = 0;\n  var map = new Map(); // 对每种 NodeType 做编号处理\n\n  return function key2Id(key) {\n    var id = map.get(key);\n    if (!id) {\n      id = (++uuid).toString(32);\n      map.set(key, id);\n    }\n    return id;\n  };\n}\nvar isArrReg = /^iAr/; // 对每种 NodeType 做编号处理\n\nvar key2Id = getKey2Id(); // 获取节点的渲染路径，作为节点的 X 坐标\n\nvar genRenderPath = function genRenderPath(node) {\n  return node[\"return\"] ? [node].concat(_toConsumableArray(genRenderPath(node[\"return\"]))) : [node];\n}; // 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\n\nvar getNodeId = function getNodeId(fiberNode) {\n  // FIXME: 使用 index 作为 Y 坐标是十分不可靠的行为，待想出更好的法子替代\n  var id = _get(fiberNode, 'key') || fiberNode.index;\n  var nodeKey = _get(fiberNode, 'memoizedProps._nk') || _get(fiberNode, 'pendingProps._nk');\n  var isArray = _isString(nodeKey) && isArrReg.test(nodeKey);\n  return isArray ? \"\".concat(nodeKey, \".\").concat(id) : nodeKey || id;\n};\nvar markNode = function markNode(node) {\n  var x = key2Id(_get(node, 'type.$$typeof', node.type));\n  var y = getNodeId(node);\n  return \"\".concat(x, \",\").concat(y);\n}; // 根据 X,Y 坐标生成 Key\n\nvar getKeyByCoord = function getKeyByCoord(nodes, handleNode) {\n  return nodes.map(function (node) {\n    var mark = markNode(node);\n    return _isFunction(handleNode) ? _run(handleNode, undefined, node, mark) : mark;\n  }).filter(Boolean).join('|');\n};\nvar getKeyByFiberNode = function getKeyByFiberNode(fiberNode, handleNode) {\n  var key = getKeyByCoord(genRenderPath(fiberNode), handleNode);\n  return key2Id(key);\n};\nvar isArrReg$1 = /^iAr/; // 对每种 NodeType 做编号处理\n\nvar key2Id$1 = getKey2Id(); // 获取节点的渲染路径，作为节点的 X 坐标\n\nvar genRenderPath$1 = function genRenderPath(node) {\n  return node.__ ? [node].concat(_toConsumableArray(genRenderPath(node.__))) : [node];\n}; // 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\n\nvar getNodeId$1 = function getNodeId(node) {\n  // FIXME: Preact 无 index 属性，无 key 与 _nk 之下 Y 坐标不可靠，待修正\n  var id = _get(node, 'key') || node.index;\n  var nodeKey = _get(node, 'props._nk');\n  var isArray = _isString(nodeKey) && isArrReg$1.test(nodeKey);\n  return isArray ? \"\".concat(nodeKey, \".\").concat(id) : nodeKey || id;\n};\nvar markNode$1 = function markNode(node) {\n  var x = key2Id$1(node.type);\n  var y = getNodeId$1(node);\n  return \"\".concat(x, \",\").concat(y);\n}; // 根据 X,Y 坐标生成 Key\n\nvar getKeyByCoord$1 = function getKeyByCoord(nodes, handleNode) {\n  return nodes.map(function (node) {\n    var mark = markNode$1(node);\n    return _isFunction(handleNode) ? _run(handleNode, undefined, node, mark) : mark;\n  }).filter(Boolean).join('|');\n};\nvar getKeyByNode = function getKeyByNode(node, handleNode) {\n  var key = getKeyByCoord$1(genRenderPath$1(node), handleNode);\n  return key2Id$1(key);\n};\nvar type; // 根据 FiberNode 所处位置来确定 nodeKey\n\nvar NodeKey = /*#__PURE__*/function (_Component) {\n  _inherits(NodeKey, _Component);\n  var _super = _createSuper(NodeKey);\n  function NodeKey() {\n    var _this;\n    _classCallCheck(this, NodeKey);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"key\", null);\n    _defineProperty(_assertThisInitialized(_this), \"genKey\", function (onHandleNode) {\n      if (!type) {\n        // _reactInternals 为 React v17 fiberNode 节点字段\n        if (_this._reactInternalFiber || _this._reactInternals) {\n          type = 'React';\n        } // TODO: May \"preact/compat\" mode only, not verified yet.\n\n        if (_this.__v) {\n          type = 'Preact';\n        }\n      }\n      switch (type) {\n        case 'Preact':\n          {\n            _this.key = getKeyByNode(_this.__v, onHandleNode);\n            break;\n          }\n        case 'React':\n          {\n            var fiberNode = _this._reactInternalFiber || _this._reactInternals;\n            _this.key = getKeyByFiberNode(fiberNode, onHandleNode);\n            break;\n          }\n      }\n      return _this.key;\n    });\n    return _this;\n  }\n  _createClass(NodeKey, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        manualKey = _this$props.manualKey,\n        children = _this$props.children,\n        prefix = _this$props.prefix,\n        onHandleNode = _this$props.onHandleNode;\n      return _run(children, undefined, \"\".concat(prefix).concat(this.key || this.genKey(onHandleNode)));\n    }\n  }]);\n  return NodeKey;\n}(react.Component);\n_defineProperty(NodeKey, \"defaultProps\", {\n  onHandleNode: undefined,\n  manualKey: undefined,\n  prefix: ''\n});\nexports.default = NodeKey;","map":{"version":3,"names":["getKey2Id","uuid","map","Map","key2Id","key","id","get","toString","set","isArrReg","genRenderPath","node","concat","_toConsumableArray","getNodeId","fiberNode","_get","index","nodeKey","isArray","_isString","test","markNode","x","type","y","getKeyByCoord","nodes","handleNode","mark","_isFunction","_run","undefined","filter","Boolean","join","getKeyByFiberNode","isArrReg$1","key2Id$1","genRenderPath$1","__","getNodeId$1","markNode$1","getKeyByCoord$1","getKeyByNode","NodeKey","_Component","onHandleNode","_this","_reactInternalFiber","_reactInternals","__v","_this$props","props","manualKey","children","prefix","genKey","react","Component"],"sources":["/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-node-key/src/helpers/index.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-node-key/src/core/NodeKey/getKeyByFiberNode.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-node-key/src/core/NodeKey/getKeyByPreactNode.js","/media/starrynight/main_pt/projects_linux/blog_website/frontend/blog-website/node_modules/react-node-key/src/core/NodeKey/index.js"],"sourcesContent":["export function getKey2Id() {\n  let uuid = 0\n  const map = new Map()\n\n  // 对每种 NodeType 做编号处理\n  return function key2Id(key) {\n    let id = map.get(key)\n\n    if (!id) {\n      id = (++uuid).toString(32)\n      map.set(key, id)\n    }\n\n    return id\n  }\n}\n","import { isString, isFunction, get, run } from 'szfe-tools'\n\nimport { getKey2Id } from '../../helpers'\n\nconst isArrReg = /^iAr/\n\n// 对每种 NodeType 做编号处理\nconst key2Id = getKey2Id()\n\n// 获取节点的渲染路径，作为节点的 X 坐标\nconst genRenderPath = (node) =>\n  node.return ? [node, ...genRenderPath(node.return)] : [node]\n\n// 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\nconst getNodeId = (fiberNode) => {\n  // FIXME: 使用 index 作为 Y 坐标是十分不可靠的行为，待想出更好的法子替代\n  const id = get(fiberNode, 'key') || fiberNode.index\n  const nodeKey = get(fiberNode, 'memoizedProps._nk') || get(fiberNode, 'pendingProps._nk')\n  const isArray = isString(nodeKey) && isArrReg.test(nodeKey)\n\n  return isArray ? `${nodeKey}.${id}` : nodeKey || id\n}\n\nconst markNode = (node) => {\n  const x = key2Id(get(node, 'type.$$typeof', node.type))\n  const y = getNodeId(node)\n\n  return `${x},${y}`\n}\n\n// 根据 X,Y 坐标生成 Key\nconst getKeyByCoord = (nodes, handleNode) =>\n  nodes\n    .map((node) => {\n      const mark = markNode(node)\n\n      return isFunction(handleNode)\n        ? run(handleNode, undefined, node, mark)\n        : mark\n    })\n    .filter(Boolean)\n    .join('|')\n\nconst getKeyByFiberNode = (fiberNode, handleNode) => {\n  const key = getKeyByCoord(genRenderPath(fiberNode), handleNode)\n\n  return key2Id(key)\n}\n\nexport default getKeyByFiberNode\n","import { isString, isFunction, get, run } from 'szfe-tools'\n\nimport { getKey2Id } from '../../helpers'\n\nconst isArrReg = /^iAr/\n\n// 对每种 NodeType 做编号处理\nconst key2Id = getKey2Id()\n\n// 获取节点的渲染路径，作为节点的 X 坐标\nconst genRenderPath = (node) =>\n  node.__ ? [node, ...genRenderPath(node.__)] : [node]\n\n// 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\nconst getNodeId = (node) => {\n  // FIXME: Preact 无 index 属性，无 key 与 _nk 之下 Y 坐标不可靠，待修正\n  const id = get(node, 'key') || node.index\n  const nodeKey = get(node, 'props._nk')\n  const isArray = isString(nodeKey) && isArrReg.test(nodeKey)\n\n  return isArray ? `${nodeKey}.${id}` : nodeKey || id\n}\n\nconst markNode = (node) => {\n  const x = key2Id(node.type)\n  const y = getNodeId(node)\n\n  return `${x},${y}`\n}\n\n// 根据 X,Y 坐标生成 Key\nconst getKeyByCoord = (nodes, handleNode) =>\n  nodes\n    .map((node) => {\n      const mark = markNode(node)\n\n      return isFunction(handleNode)\n        ? run(handleNode, undefined, node, mark)\n        : mark\n    })\n    .filter(Boolean)\n    .join('|')\n\nconst getKeyByNode = (node, handleNode) => {\n  const key = getKeyByCoord(genRenderPath(node), handleNode)\n\n  return key2Id(key)\n}\n\nexport default getKeyByNode\n","import { Component } from 'react'\nimport { run } from 'szfe-tools'\n\nimport getKeyByFiberNode from './getKeyByFiberNode'\nimport getKeyByPreactNode from './getKeyByPreactNode'\n\nlet type\n\n// 根据 FiberNode 所处位置来确定 nodeKey\nexport default class NodeKey extends Component {\n  static defaultProps = {\n    onHandleNode: undefined,\n    manualKey: undefined,\n    prefix: '',\n  }\n\n  key = null\n  genKey = (onHandleNode) => {\n    if (!type) {\n      // _reactInternals 为 React v17 fiberNode 节点字段\n      if (this._reactInternalFiber || this._reactInternals) {\n        type = 'React'\n      }\n\n      // TODO: May \"preact/compat\" mode only, not verified yet.\n      if (this.__v) {\n        type = 'Preact'\n      }\n    }\n\n    switch (type) {\n      case 'Preact': {\n        this.key = getKeyByPreactNode(this.__v, onHandleNode)\n        break\n      }\n      case 'React': {\n        const fiberNode = this._reactInternalFiber || this._reactInternals\n        this.key = getKeyByFiberNode(fiberNode, onHandleNode)\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    return this.key\n  }\n\n  render() {\n    const { manualKey, children, prefix, onHandleNode } = this.props\n\n    return run(\n      children,\n      undefined,\n      `${prefix}${manualKey, this.key || this.genKey(onHandleNode)}`\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}